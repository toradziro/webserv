#include <common_inc.h>
#include <FileFuncs.hpp>
#include <GetRequestHandler.hpp>
#include <algorithm>

const std::string page404 = "./test_files/404_not_found.html"; 
const std::string autoindexHeader = "<!DOCTYPE html>\n<html>\n<body>\n\t<h1>AUTOGENERATED INDEX HTML</h1>\n";
const std::string autoindexEnd = "</body>\n</html>\n";
const std::string indexFileNameHtml = "/index.html";
const std::string httpType = "HTTP/1.1";

GetRequestHandler::GetRequestHandler(RequestConfig requestConfig) : 
                m_requestConfig(std::move(requestConfig))
{
}

static bool validateLocation(const std::string& serverRoot, const std::string& requestedLocation) {
    std::cout << "Server root is: " << serverRoot << std::endl;
    std::cout << "Requested location is: " << requestedLocation << std::endl;
    for(size_t i = 0; i < serverRoot.size(); ++i) {
        if(serverRoot[i] != requestedLocation[i]) {
            return false;
        }
    }
    return true;
}

void GetRequestHandler::prepareResponce() {
    if(validateLocation(m_requestConfig.m_serverRoot, m_requestConfig.m_location) && isFileExists(m_requestConfig.m_location)) {
        m_responseCode = "200 OK";
        m_contentType = m_requestConfig.m_contentTypes->getContentTypeByExtention(getFileExtention(m_requestConfig.m_location));
    } else {
        m_contentType = "text/html";
        m_responseCode = "404 Not Found";
        m_requestConfig.m_location = page404;
    }
    m_fileFd = open(m_requestConfig.m_location.c_str(), O_RDONLY);
    checkError(m_fileFd == -1, "can't open file");
    switch(fileType(m_fileFd))
    {
        case FT_FILE:
            // regular send by chanks
            fillRegularFileInfo();
            break;

        case FT_DIRECTORY:
            // need to check info.html, if no - generate it
            fillIndex();
            break;
        case FT_NONE:
        default:
            // TODO: fix to log
            checkError(true, "unknown file type");
            break;
    }
}

void GetRequestHandler::sendResponse() {
    std::string resultMessage = "";
    resultMessage += httpType + " " + m_contentType + "\n" 
                + "Content-Type: " + m_contentType + "\n" 
                + "Content-Length: " + std::to_string(m_bodySize) + "\n\n";
    send(m_requestConfig.m_clientFd, resultMessage.c_str(), resultMessage.size(), 0);
    int wasSent = 0;
    while(wasSent < m_bodySize) {
        int currSent = 0;
        currSent = getNextChank();
        send(m_requestConfig.m_clientFd, m_buffer, bufferSize, 0);
        wasSent += currSent;
    }
    if(m_fileFd != -1) {
        close(m_fileFd);
    }
    close(m_requestConfig.m_clientFd);
    std::cout << "succesfully sent data\n" << std::endl;
}

void GetRequestHandler::fillRegularFileInfo() {
    m_bodySize = getFileSize(m_fileFd);
}

void GetRequestHandler::fillIndex() {
    if(dirContainsFile(m_requestConfig.m_location, "index.html")) {
        if(m_requestConfig.m_location[m_requestConfig.m_location.size() - 1] != '/') {
            m_requestConfig.m_location += '/';
        }
        std::string filename = m_requestConfig.m_location + "index.html";
        m_fileFd = open(filename.c_str(), O_RDONLY);
        checkError(m_fileFd == -1, "can't open file");
        m_bodySize = getFileSize(m_fileFd);
    } else {
        // generating autoindex
        m_isAutoindex = true;
        m_generatedAutoindex += autoindexHeader;
        std::vector<std::string> filesList = listDirContent(m_requestConfig.m_location);
        std::sort(filesList.begin(), filesList.end());
        for(size_t i = 0; i < filesList.size(); ++i) {
            std::string body = ""; 
            body += "\t<a href=\"http://"; 
            body += m_requestConfig.requestHeaderTable.Get("Host:");
            body += m_requestConfig.m_location;
            if(body[body.size() - 1] != '/') {
                body += "/";
            }
            body += filesList[i];
            body += "\">" + filesList[i] + "</a><br>\n";
            m_generatedAutoindex += body;
        }
        m_generatedAutoindex += autoindexEnd;
        m_bodySize = m_generatedAutoindex.size();
    }
}

int GetRequestHandler::getNextChank() {
    memset(m_buffer, 0, bufferSize);
    int res = 0;
    if(m_isAutoindex) {
        while(res < bufferSize && m_currentAutoindexIt < m_generatedAutoindex.size()) {
            m_buffer[res] = m_generatedAutoindex[m_currentAutoindexIt];
            ++m_currentAutoindexIt;
            ++res;
        }
    } else {
        res = read(m_fileFd, m_buffer, bufferSize);
    }
    return res;
}
