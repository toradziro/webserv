#include <ResponseGET.hpp>

// <head>\n\t<title>\"AUTOGENERATED INDEX HTML\"</title>\n</head>\n

const char* autoindexHeader = "<!DOCTYPE html>\n<html>\n<body>\n\t<h1>AUTOGENERATED INDEX HTML</h1>\n";
const char* autoindexEnd = "</body>\n</html>\n";
const char* page404 = "./test_files/404_not_found.html"; 
const char* indexFileNameHtml = "/index.html";
std::string httpType = "HTTP/1.1";

ResponseGET::ResponseGET(ResponseInfo info) : 
    m_contentType(""),
    m_hostPort(info.m_hostPort),
    m_contentTypes(info.m_contentTypes),
    m_responseCode(RC_LENGTH),
    m_fileType(FT_NONE),
    m_requestLocation(info.m_requestLocation),
    m_tmpFilePath(nullptr),
    m_clientFd(info.m_clientFd),
    m_bodySize(0),
    m_fileFd(0)
{ }

void ResponseGET::prepareResponce() {
    if(isFileExists(m_requestLocation)) {
        m_responseCode = RC_200;
        m_contentType = m_contentTypes->getContentTypeByExtention(getFileExtention(m_requestLocation));
    } else {
        m_contentType = "text/html";
        free(m_requestLocation);
        m_requestLocation = nullptr;
        m_requestLocation = strdup(page404);
        m_responseCode = RC_404;
    }
    m_fileFd = open(m_requestLocation, O_RDONLY);
    checkError(m_fileFd == -1, "can't open file");
    switch(fileType(m_fileFd))
    {
    case FT_FILE:
    // regular send by chanks
        fillRegularFileInfo();
        break;
    
    case FT_DIRECTORY:
    // need to check info.html, if no - generate it
        fillIndex();
        break;
    case FT_NONE:
    default:
        // TODO: fix to log
        assert(false);
        break;
    }
}

void ResponseGET::sendResponse() {
    std::string resultMessage = "";
    resultMessage += httpType + " " + codeToString() + "\n" 
                + "Content-Type: " + m_contentType + "\n" 
                + "Content-Length: " + std::to_string(m_bodySize) + "\n\n";
    send(m_clientFd, resultMessage.c_str(), resultMessage.size(), 0);
    int wasSent = 0;
    while(wasSent < m_bodySize) {
        int currSent = 0;
        currSent = getNextChank();
        send(m_clientFd, m_buffer, BUFF_SIZE, 0);
        wasSent += currSent;
    }
    close(m_fileFd);
    if(m_tmpFilePath != nullptr) {
        unlink(m_tmpFilePath);
        free(m_tmpFilePath);
        m_tmpFilePath = nullptr;
    }
    if(m_requestLocation != nullptr) {
        free(m_requestLocation);
        m_requestLocation = nullptr;
    }
    std::cout << "succesfully sent data\n" << std::endl;
}

// Private Part
void ResponseGET::fillIndex() {
    int resFileFd = 0;
    if(dirContainsFile(m_requestLocation, &indexFileNameHtml[1])) {
        char* indexFileName = strdup(m_requestLocation);
        int additionalLength = strlen(indexFileNameHtml) + 1;
        indexFileName = (char*)realloc((void*)indexFileName, strlen(indexFileName) + additionalLength);
        indexFileName = strcat(indexFileName, indexFileNameHtml);
        resFileFd = open(indexFileName, O_RDONLY);
        checkError(resFileFd == -1, "openError");
        m_tmpFilePath = nullptr;
        free(indexFileName);
    } else {
        char* tmpFileName = strdup(m_requestLocation);
        if(strlen(tmpFileName) < 6) {
            tmpFileName = (char*)realloc((void*)tmpFileName, strlen(tmpFileName) + 6);
        } 
        memset((void*)&tmpFileName[strlen(tmpFileName) - 6], 'X', 6);
        printf("%s\n", tmpFileName);
        resFileFd = mkstemp(tmpFileName);
        checkError(resFileFd == -1, "error creating temp file")
        write(resFileFd, autoindexHeader, strlen(autoindexHeader));
        std::vector<std::string> filesList = listDirContent(m_requestLocation);
        for(size_t i = 0; i < filesList.size(); ++i) {
            std::string body = ""; 
            body += "\t<a href=\"http://"; 
            body += m_hostPort;
            body += m_requestLocation;
            if(body[body.size() - 1] != '/') {
                body += "/";
            }
            body += filesList[i];
            body += "\">" + filesList[i] + "</a><br>\n";
            write(resFileFd, body.c_str(), body.size());
        }
        write(resFileFd, autoindexEnd, strlen(autoindexEnd));
        m_tmpFilePath = tmpFileName;
    }

    close(m_fileFd);
    m_fileFd = resFileFd;
    checkError((lseek(m_fileFd, 0, SEEK_SET)) == -1, "lseek error");
    m_bodySize = getFileSize(m_fileFd);
    m_contentType = "text/html";
#ifdef _DEBUG
    std::cout << "\n\nTEMP FILE CONTENT:" << std::endl;
    char localBuf[10000];
    memset((void*)localBuf, '\0', 10000);
    while((read(m_fileFd, localBuf, 10000)) != 0) {
        printf("%s", localBuf);
        memset((void*)localBuf, '\0', 10000);
    }
    checkError((lseek(m_fileFd, 0, SEEK_SET)) == -1, "lseek error");
#endif
}

void ResponseGET::fillRegularFileInfo() {
    m_bodySize = getFileSize(m_fileFd);
}

int ResponseGET::getNextChank() {
    memset(m_buffer, 0, BUFF_SIZE);
    return read(m_fileFd, m_buffer, BUFF_SIZE);
}

std::string ResponseGET::codeToString() {
    switch(m_responseCode) {
        case RC_200:
            return "200 OK";
            break;
        case RC_404:
            return "404 Not Found";
            break;
        default:
            break;
    }
    return "404 Not Found";
}
